<!DOCTYPE html>
  
  
  
  
   <html class="no-js"> 

  <head lang="en-us">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=10" />
    <title>Atmosphere - Scalatra</title>
    <meta name="generator" content="Hugo 0.19" />

    
    <meta name="description" content="Documentation and how-to guides for the Scalatra microframework.">
    
    <link rel="canonical" href="https://scalatra.github.io/scalatra-docbuild/guides/2.3/async/atmosphere.html">
    

    <meta property="og:url" content="https://scalatra.github.io/scalatra-docbuild/guides/2.3/async/atmosphere.html">
    <meta property="og:title" content="Scalatra">
    <meta property="og:image" content="https://scalatra.github.io/scalatra-docbuild/images/logo.png">
    <meta name="apple-mobile-web-app-title" content="Scalatra">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <link rel="shortcut icon" type="image/x-icon" href="https://scalatra.github.io/scalatra-docbuild/images/favicon.ico">
    <link rel="icon" type="image/x-icon" href="https://scalatra.github.io/scalatra-docbuild/images/favicon.ico">

    <style>
      @font-face {
        font-family: 'Icon';
        src: url('https://scalatra.github.io/scalatra-docbuild/fonts/icon.eot?52m981');
        src: url('https://scalatra.github.io/scalatra-docbuild/fonts/icon.eot?#iefix52m981')
               format('embedded-opentype'),
             url('https://scalatra.github.io/scalatra-docbuild/fonts/icon.woff?52m981')
               format('woff'),
             url('https://scalatra.github.io/scalatra-docbuild/fonts/icon.ttf?52m981')
               format('truetype'),
             url('https://scalatra.github.io/scalatra-docbuild/fonts/icon.svg?52m981#icon')
               format('svg');
        font-weight: normal;
        font-style: normal;
      }
    </style>

    <link rel="stylesheet" href="https://scalatra.github.io/scalatra-docbuild/stylesheets/application.css">
    <link rel="stylesheet" href="https://scalatra.github.io/scalatra-docbuild/stylesheets/temporary.css">
    <link rel="stylesheet" href="https://scalatra.github.io/scalatra-docbuild/stylesheets/palettes.css">
    <link rel="stylesheet" href="https://scalatra.github.io/scalatra-docbuild/stylesheets/bootstrap-styles.css">
    <link rel="stylesheet" href="https://scalatra.github.io/scalatra-docbuild//stylesheets/highlight/highlight.css">

    
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Ubuntu:400,700|Ubuntu&#43;Mono">
    <style>
      body, input {
        font-family: 'Ubuntu', Helvetica, Arial, sans-serif;
      }
      pre, code {
        font-family: 'Ubuntu Mono', 'Courier New', 'Courier', monospace;
      }
    </style>

    
    <script src="https://scalatra.github.io/scalatra-docbuild/javascripts/modernizr.js"></script>

    

  </head>
  <body class="palette-primary-teal palette-accent-red">




<div class="backdrop">
	<div class="backdrop-paper"></div>
</div>

<input class="toggle" type="checkbox" id="toggle-drawer">
<input class="toggle" type="checkbox" id="toggle-search">
<label class="toggle-button overlay" for="toggle-drawer"></label>

<header class="header">
	<nav aria-label="Header">
  <div class="bar default">
    <div class="button button-menu" role="button" aria-label="Menu">
      <label class="toggle-button icon icon-menu" for="toggle-drawer">
        <span></span>
      </label>
    </div>
    <div class="stretch">
      <div class="title">
        Atmosphere
      </div>
    </div>

    
    <div class="button button-twitter" role="button" aria-label="Twitter">
       <a href="https://twitter.com/scalatra" title="@scalatra on Twitter" target="_blank" class="toggle-button icon icon-twitter"></a>
    </div>
    

    
    <div class="button button-github" role="button" aria-label="GitHub">
      <a href="https://github.com/scalatra/scalatra" title="@scalatra/scalatra on GitHub" target="_blank" class="toggle-button icon icon-github"></a>
    </div>
    
    
        
  </div>
  <div class="bar search">
    <div class="button button-close" role="button" aria-label="Close">
      <label class="toggle-button icon icon-back" for="toggle-search"></label>
    </div>
    <div class="stretch">
      <div class="field">
        <input class="query" type="text" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck>
      </div>
    </div>
    <div class="button button-reset" role="button" aria-label="Search">
      <button class="toggle-button icon icon-close" id="reset-search"></button>
    </div>
  </div>
</nav>
</header>

<main class="main">
	<div class="drawer">
		<nav aria-label="Navigation">
  <a href="https://scalatra.github.io/scalatra-docbuild/" class="project">
    <div class="banner">
      
        <div class="logo">
          <img src="https://scalatra.github.io/scalatra-docbuild/images/logo.png">
        </div>
      
      <div class="name">
        <strong>Scalatra </strong>
        
      </div>
    </div>
  </a>

  <div class="scrollable">
    <div class="wrapper">
      
      <div class="toc">
        
        <ul>
          
          <li><a href="https://scalatra.github.io/scalatra-docbuild/getting-started/">Getting started</a></li>
          
          <li><a href="https://scalatra.github.io/scalatra-docbuild/news.html">News</a></li>
          
          <li><a href="https://scalatra.github.io/scalatra-docbuild/guides/2.5/">Guides</a></li>
          
          <li><a href="https://scalatra.github.io/scalatra-docbuild/community/">Community</a></li>
          
          
        </ul>
        

        
        <a href="https://www.manning.com/books/scalatra-in-action" target="_blank">
          <img src="https://scalatra.github.io/scalatra-docbuild/images/book-cover.png" alt="Scalatra in Action">
        </a>
      </div>
    </div>
  </div>
</nav>

	</div>

	<article class="article">
		<div class="wrapper">
			<h1>Atmosphere </h1>

			

<p>Scalatra has a built-in integration with
<a href="https://github.com/Atmosphere/atmosphere">Atmosphere</a>, the asynchronous
websocket/comet framework. Atmosphere allows you to keep a persistent
connection alive between the server and the user&rsquo;s browser (or other
user-agents). You can push new information to your user at any time,
without a page refresh.</p>

<p>It&rsquo;s carefree server push for the JVM.</p>

<hr />

<h3 id="atmosphere-example-app">Atmosphere example app</h3>

<div class="alert alert-info">
  <span class="badge badge-info"><i class="icon-flag icon-white"></i></span>
  See
  <a href="https://github.com/scalatra/scalatra-website-examples/tree/master/2.2/async/scalatra-atmosphere-example">scalatra-atmosphere-example</a>
  for a minimal and standalone project containing the example in this guide.
</div>

<h4 id="generating-the-app">Generating the app</h4>

<p>Generate a project using <code>g8 scalatra/scalatra-sbt</code>, and call your
initial servlet <code>ChatController</code>.</p>

<p>You&rsquo;ll need to do a few things to a default Scalatra project in order
to get it ready for use with Atmosphere.</p>

<h4 id="dependencies">Dependencies</h4>

<p>The following dependencies will be needed to make the sample application
work.</p>

<pre><code class="language-scala">  &quot;org.json4s&quot;                  %% &quot;json4s-jackson&quot;      % &quot;3.2.11&quot;,
  &quot;org.scalatra&quot;                %% &quot;scalatra&quot;            % &quot;2.3.1&quot;,
  &quot;org.scalatra&quot;                %% &quot;scalatra-scalate&quot;    % &quot;2.3.1&quot;,
  &quot;org.scalatra&quot;                %% &quot;scalatra-specs2&quot;     % &quot;2.3.1&quot;  % &quot;test&quot;,
  &quot;org.scalatra&quot;                %% &quot;scalatra-atmosphere&quot; % &quot;2.3.1&quot;,
  &quot;ch.qos.logback&quot;              %  &quot;logback-classic&quot;     % &quot;1.1.2&quot;   % &quot;runtime&quot;,
  &quot;org.eclipse.jetty&quot;           %  &quot;jetty-plus&quot;          % &quot;9.2.10.v20150310&quot;     % &quot;container;provided&quot;,
  &quot;org.eclipse.jetty&quot;           %  &quot;jetty-webapp&quot;        % &quot;9.2.10.v20150310&quot;     % &quot;container&quot;,
  &quot;org.eclipse.jetty.websocket&quot; %  &quot;websocket-server&quot;    % &quot;9.2.10.v20150310&quot;     % &quot;container;provided&quot;,
  &quot;javax.servlet&quot;               %  &quot;javax.servlet-api&quot;   % &quot;3.1.0&quot;   % &quot;container;provided;test&quot; artifacts Artifact(&quot;javax.servlet-api&quot;, &quot;jar&quot;, &quot;jar&quot;)
</code></pre>

<h4 id="imports">Imports</h4>

<p>Your imports should look like this:</p>

<pre><code class="language-scala">package org.scalatra.example.atmosphere

import java.util.Date

import org.json4s.JsonDSL._
import org.json4s._
import org.scalatra._
import org.scalatra.atmosphere._
import org.scalatra.json.{JValueResult, JacksonJsonSupport}
import org.scalatra.scalate.ScalateSupport

import scala.concurrent.ExecutionContext.Implicits.global
</code></pre>

<h4 id="writing-the-chatcontroller">Writing the ChatController</h4>

<p>The basic setup of an Atmosphere-enabled servlet and route looks like
this:</p>

<pre><code class="language-scala">class ChatController extends ScalatraServlet
  with ScalateSupport with JValueResult
  with JacksonJsonSupport with SessionSupport
  with AtmosphereSupport {

  atmosphere(&quot;/the-chat&quot;) {
    new AtmosphereClient {
      def receive = {
          case Connected =&gt;
          case Disconnected(disconnector, Some(error)) =&gt;
          case Error(Some(error)) =&gt;
          case TextMessage(text) =&gt; send(&quot;ECHO: &quot; + text)
          case JsonMessage(json) =&gt; broadcast(json)
        }
      }
    }
  }
</code></pre>

<p>The AtmosphereSupport trait adds a new kind of route matcher to your
controller, sitting alongside the regular HTTP <code>get</code>, <code>put</code>,
<code>post</code>, <code>delete</code> and friends: you&rsquo;ve now got an <code>atmosphere</code> route type,
which can be used to bind persistent socket connections to your
application.</p>

<p>Inside the <code>atmosphere</code> route, you instantiate a <code>new AtmosphereClient</code>
and define a <code>receive</code> method, which listens for events.</p>

<p>One AtmosphereClient is instantiated per connected user. It&rsquo;s worth
taking a look at the
<a href="http://scalatra.org/2.2/api/#org.scalatra.atmosphere.AtmosphereClient">ScalaDocs</a> and <a href="https://github.com/scalatra/scalatra/blob/develop/atmosphere/src/main/scala/org/scalatra/atmosphere/AtmosphereClient.scala">source</a> for AtmosphereClient to see what it can do.</p>

<p>As you can see, there are quite a few kinds of events which Scalatra&rsquo;s
atmosphere integration can deal with:</p>

<ul>
<li><code>Connected</code></li>
<li><code>Disconnected</code></li>
<li><code>Error</code></li>
<li><code>TextMessage</code></li>
<li><code>JsonMessage</code></li>
</ul>

<p>Scala pattern matching is used to detect which type of event has
occurred, and the function for each case can be set to do something
about the event. For instance, you might want to broadcast a message
to all connected clients when a new client connects:</p>

<pre><code class="language-scala">  case Connected =&gt;
</code></pre>

<p>You can notify clients with an implementation like this:</p>

<pre><code class="language-scala">  case Connected =&gt;
    println(&quot;Client %s is connected&quot; format uuid)
    broadcast((&quot;author&quot; -&gt; &quot;Someone&quot;) ~ (&quot;message&quot; -&gt; &quot;joined the room&quot;) ~ (&quot;time&quot; -&gt; (new Date().getTime.toString )), Everyone)
</code></pre>

<p>The <code>uuid</code> in that code comes from the AtmosphereClient instance - each
connected user gets its own client with a unique identifier, and
Scalatra keeps a list of atmosphere clients which are connected to
a given <code>atmosphere</code> route.</p>

<p>Let&rsquo;s see sample code for all of the Atmosphere event types:</p>

<pre><code class="language-scala">atmosphere(&quot;/the-chat&quot;) {
    new AtmosphereClient {
      def receive: AtmoReceive = {
        case Connected =&gt;
          println(&quot;Client %s is connected&quot; format uuid)
          broadcast((&quot;author&quot; -&gt; &quot;Someone&quot;) ~ (&quot;message&quot; -&gt; &quot;joined the room&quot;) ~ (&quot;time&quot; -&gt; (new Date().getTime.toString )), Everyone)

        case Disconnected(ClientDisconnected, _) =&gt;
          broadcast((&quot;author&quot; -&gt; &quot;Someone&quot;) ~ (&quot;message&quot; -&gt; &quot;has left the room&quot;) ~ (&quot;time&quot; -&gt; (new Date().getTime.toString )), Everyone)

        case Disconnected(ServerDisconnected, _) =&gt;
          println(&quot;Server disconnected the client %s&quot; format uuid)
        case _: TextMessage =&gt;
          send((&quot;author&quot; -&gt; &quot;system&quot;) ~ (&quot;message&quot; -&gt; &quot;Only json is allowed&quot;) ~ (&quot;time&quot; -&gt; (new Date().getTime.toString )))

        case JsonMessage(json) =&gt;
          println(&quot;Got message %s from %s&quot;.format((json \ &quot;message&quot;).extract[String], (json \ &quot;author&quot;).extract[String]))
          val msg = json merge ((&quot;time&quot; -&gt; (new Date().getTime().toString)): JValue)
          broadcast(msg) // by default a broadcast is to everyone but self
          //  send(msg) // also send to the sender
      }
    }
  }

  error {
    case t: Throwable =&gt; t.printStackTrace()
  }
</code></pre>

<p>The <code>~</code> operator is used quite a bit there. It&rsquo;s a JSON operator which
turns <code>(&quot;name&quot; -&gt; &quot;joe&quot;) ~ (&quot;age&quot; -&gt; 35)</code> into <code>{&quot;name&quot;:&quot;joe&quot;,&quot;age&quot;:35}</code>.</p>

<p>That&rsquo;s pretty much it on the server side.</p>

<h4 id="javascript-client">JavaScript client</h4>

<p>Browser clients can connect to the <code>atmosphere</code> route using a JavaScript
client.</p>

<p>Atmosphere has its own connection library, which will assess the browser client
it&rsquo;s hosted in and figure out which of the available transport types will work, falling back as necessary to maintain connectivity in a wide range of
possible clients.</p>

<p>You&rsquo;re strongly advised to read Atmosphere&rsquo;s
<a href="https://github.com/Atmosphere/atmosphere/wiki/jQuery.atmosphere.js-atmosphere.js-API">extensive documentation</a>
in order to understand your connection options.</p>

<p>Besides the basic connectivity provided by the Atmosphere connector,
you&rsquo;ll need to provide your own application-specific logic, also in
JavaScript. Here&rsquo;s an <code>application.js</code> file for our chat application:</p>

<p><a href="https://github.com/scalatra/scalatra-website-examples/blob/master/2.3/async/scalatra-atmosphere-example/src/main/webapp/js/application.js">https://github.com/scalatra/scalatra-website-examples/blob/master/2.2/async/scalatra-atmosphere-example/src/main/webapp/js/application.js</a></p>

<p>Drop that code into <code>webapp/js/atmosphere.js</code>, and put the
<a href="https://github.com/scalatra/scalatra-website-examples/blob/master/2.3/async/scalatra-atmosphere-example/src/main/webapp/js/jquery-atmosphere.js">Atmosphere JavaScript client</a>
alongside it, and you&rsquo;ve got a working client implementation.</p>

<p>A few key points in <code>application.js</code>.</p>

<p>The first part of the code demonstrates the detection of available
capabilities in the user&rsquo;s browser. It loops through an array of
available transports and checks each one to see if it&rsquo;s supported,
then outputs what it finds into the page.</p>

<p>The code then makes an initial request to our <code>atmosphere</code> route at
<code>atmosphere(&quot;/the-chat&quot;)</code>, and sets up callbacks for <code>onOpen</code>,
<code>onLocalMessage</code>, <code>onTransportFailure</code>, <code>onReconnect</code>, <code>onMessage</code>,
<code>onClose</code>, and <code>onError</code> events. Check the Atmosphere docs to see
what each of these mean.</p>

<p>Lastly, there&rsquo;s a simple key-press detection which sends a chat
message to the server whenever the <code>enter</code> key is pressed.</p>

<p>With all of this in place, you can add a few <a href="https://github.com/scalatra/scalatra-website-examples/tree/master/2.3/async/scalatra-atmosphere-example/src/main/webapp/WEB-INF">Scalate views</a>
to your chat application and it&rsquo;s all done. The example application has
a default layout and action which will serve up a browser-based chat
client.</p>

<p>You should be able to connect to it from any browser which supports
JavaScript. Try opening several different browsers (e.g. Firefox and
Chrome) and signing in as different users, then chat to each other by
going to <a href="http://localhost:8080/">http://localhost:8080/</a> and hitting
the running application. You can also open multiple tabs in the
same browser to see Atmosphere detect multiple local instances and use
its <code>onLocalMessage</code> handler.</p>

<h3 id="segmenting-message-delivery">Segmenting message delivery</h3>

<p>You can easily decide which connected clients you&rsquo;d like to send a given
message to.</p>

<p>By default, the AtmosphereClient&rsquo;s <code>broadcast</code> method mimics standard
chat server functionality - calling <code>broadcast(message)</code> sends the
supplied message to all connected users except the current one.</p>

<p>The <code>send(message)</code> method does exactly the opposite: it sends the
message to only the current client.</p>

<p>The AtmosphereClient implements several default filters so that it can
decide which clients should receive a message:</p>

<pre><code class="language-scala">  final protected def SkipSelf: ClientFilter = _.uuid != uuid
  final protected def OnlySelf: ClientFilter = _.uuid == uuid
  final protected val Everyone: ClientFilter = _ =&gt; true
</code></pre>

<p>If you need to segment message delivery further than this, for example
in order to enforce security rules, you can subclass AtmosphereClient
and implement your own ClientFilters:</p>

<pre><code class="language-scala">class SecureClient extends AtmosphereClient {

  // adminUuids is a collection of uuids for admin users. You'd need to
  // add each admin user's uuid to the list at connection time.
  final protected def OnlyAdmins: ClientFilter = adminUuids.contains(_.uuid)

  /**
   * Broadcast a message to admin users only.
   */
  def adminBroadcast(msg) {
    broadcast(msg, OnlyAdmins)
  }
}
</code></pre>

<p>You could then use <code>SecureClient</code> in your <code>atmosphere</code> route instead of
the default <code>AtmosphereClient</code>:</p>

<pre><code class="language-scala">atmosphere(&quot;/the-chat&quot;) {
  new SecureClient {
    // your events would go here.
  }
}
</code></pre>

<h3 id="cleaning-up-the-case-statements">Cleaning up the case statements</h3>

<p>This subclassing approach is also an excellent way to clean up the code
in your pattern matching blocks. If it starts getting out of hand, you
can put whatever methods you need in your AtmosphereClient subclass and
end up with something like this:</p>

<pre><code class="language-scala">class MyClient extends AtmosphereClient {

  def broadcastMessage(json: String) {
    println(&quot;Got message %s from %s&quot;.format((json \ &quot;message&quot;).extract[String], (json \ &quot;author&quot;).extract[String]))
    val msg = json merge ((&quot;time&quot; -&gt; (new Date().getTime().toString)): JValue)
    broadcast(msg)
  }

}
</code></pre>

<p>And you&rsquo;d use it like this:</p>

<pre><code class="language-scala">atmosphere(&quot;/the-chat&quot;) {
  new MyClient {
    def receive = {
      // Let's use our new broadcastMessage function from MyClient:
      case JsonMessage(json) =&gt; broadcastMessage(json)

      // ... implement other message types
    }
  }
}
</code></pre>

<h3 id="broadcasting-server-side-events">Broadcasting server-side events</h3>

<p>Atmosphere event sources don&rsquo;t necessarily need to be other Atmosphere
connections.</p>

<p>You could, for instance, use an AMQP message queue to
broadcast events to connected browser clients whenever your application receives
a given message type. You could broadcast messages to all connected clients, or
to a selected group of clients, when a database record was updated, or when a
user&rsquo;s friend logged in.</p>

<p>Each Scalatra servlet that registers an Atmosphere route gets access to an
AtmosphereClient object, which can act as a broadcaster.</p>

<p>So if you have a servlet that has 3 Atmosphere routes, and it&rsquo;s mounted
at <code>/real-time-buzz</code>, you can send messages to all connected clients
with <code>AtmosphereClient.broadcast(&quot;/real-time-buzz/fizz&quot;, message)</code>, where
<code>atmosphere(&quot;/fizz&quot;)</code> is one of the available routes.</p>

<p>Alternately, you can send to all the connected clients of all 3 endpoints in the
<code>/real-time-buzz</code> servlet <code>AtmosphereClient.broadcast(&quot;/real-time-buzz&quot;, message)</code>.</p>

<p>Lastly, you can send a message to all connected clients in all Atmosphere servlets
with <code>AtmosphereClient.broadcastAll(message)</code>.</p>

<h3 id="pattern-matching-on-atmosphere-messages">Pattern matching on Atmosphere messages</h3>

<p>It&rsquo;s possible (and in fact encouraged) to do sophisticated pattern matching
on Atmosphere message types in order to simplify your application code.</p>

<p>This gives you a very flat and extensible way of dealing with many messages
without having to serialize them into actual model classes.</p>

<pre><code class="language-scala">case JsonMessage(JObject(JField(&quot;type&quot;, JString(&quot;event_1&quot;)) :: fields) =&gt;
case JsonMessage(args @ JObject(JField(&quot;type&quot;, JString(&quot;event_1&quot;)) :: fields) =&gt;
</code></pre>

<h3 id="wire-formats">Wire formats</h3>

<p>Data travelling between the browser and the websocket server needs to be in a
defined transport format, called a wire format, before it reaches the Atmosphere
client.</p>

<p>You can define your own wire formats by extending the
<a href="https://github.com/scalatra/scalatra/blob/develop/atmosphere/src/main/scala/org/scalatra/atmosphere/wire_format.scala">WireFormat</a>
trait. To create a new wire format, extend WireFormat and implement its methods
in your subclass.</p>

<h2 id="building-an-embedded-scalatra-atmosphere-application">Building an embedded Scalatra + Atmosphere application</h2>

<p>If you need to build your Atmosphere application to run embedded within Jetty, there&rsquo;s a
full code example showing you how, <a href="https://github.com/scalatra/scalatra-website-examples/tree/master/2.3/async/scalatra-atmosphere-embedded">in the Scalatra Website Examples</a> repo on Github.</p>

<p>Once you check out the code, you can build an embedded Atmosphere-enabled app which runs under Jetty, by
calling the <code>stage</code> task once you&rsquo;re in SBT. This will package a start script
for you - it can be run by calling <code>target/start</code> from the top-level project
directory. It depends on the <a href="https://github.com/sbt/sbt-start-script">sbt-start-script</a> plugin.</p>


			<aside class="copyright" role="note">
				
				&copy; 2017 Scalatra Team &ndash;
				
				Documentation built with
				<a href="https://www.gohugo.io" target="_blank">Hugo</a>
				using the
				<a href="http://github.com/digitalcraftsman/hugo-material-docs" target="_blank">Material</a> theme.
			</aside>

			<footer class="footer">
				

			</footer>
		</div>
	</article>

	<div class="results" role="status" aria-live="polite">
		<div class="scrollable">
			<div class="wrapper">
				<div class="meta"></div>
				<div class="list"></div>
			</div>
		</div>
	</div>
</main>

<script>

  var base_url = '';
  var repo_id  = '';

</script>

<script src="https://scalatra.github.io/scalatra-docbuild/javascripts/application.js"></script>


<script>
  /* Add headers to scrollspy */
  var headers   = document.getElementsByTagName("h2");
  var scrollspy = document.getElementById('scrollspy');

  if(scrollspy) {
    if(headers.length > 0) {
      for(var i = 0; i < headers.length; i++) {
        var li = document.createElement("li");
        li.setAttribute("class", "anchor");

        var a  = document.createElement("a");
        a.setAttribute("href", "#" + headers[i].id);
        a.setAttribute("title", headers[i].innerHTML);
        a.innerHTML = headers[i].innerHTML;

        li.appendChild(a)
        scrollspy.appendChild(li);
      }
    } else {
      scrollspy.parentElement.removeChild(scrollspy)
    }


    /* Add permanent link next to the headers */
    var headers = document.querySelectorAll("h1, h2, h3, h4, h5, h6");

    for(var i = 0; i < headers.length; i++) {
        var a = document.createElement("a");
        a.setAttribute("class", "headerlink");
        a.setAttribute("href", "#" + headers[i].id);
        a.setAttribute("title", "Permanent link")
        a.innerHTML = "#";
        headers[i].appendChild(a);
    }
  }
</script>



<script src="https://scalatra.github.io/scalatra-docbuild/javascripts/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

